/**
 * Disponível para teste em https://www.typescriptlang.org/pt/play?#code/MYGwhgzhAEAK4E8BmYCWAnaBvAUNaADuqgG5gAuAptANaUIDuA9ugCYBc0E5xAdgOYBuPIWJkq0ALYViAD07c+-ANoBdNcJEB6AFQ6R0HdACSvVMFRhoV0JAiUDRgAIEw6MJNr1mbaAGEACzASalZqCyR3fkpPViZrEH4WVHJUSSZHLRFgJl5FAFdgchYACjpGFg4uHlQBAEpsA2hUJGgSgEJyANQIADoegGl6ADUwEFRWMu9KuobcfAXoLvQmBmheSjWAUXQV9BKAIgB5AggAGi8K30l87mggkOgAVmh8swBHfOoQSnIqdAgBzqwkWAF8cE0uj1euUfKxoABeS5w3rFACqBAIlHQfkglBKwMh3T60hqskRS2JvWi5AAsjJULICSDoODtHpHNBhtiWuYrPZrNBgA9QuEWlEYtAAJfQEgAQ-GrDAFyY+S4lAAVsr1dKhUxJAQmNwrIbMC9gG4wEVsZQYGMUAAjKWpHJ9TkuS2eWGVfwi6BhIXisDRTz87FCgKUC1K93oX75dB5aAAJV+LF4VgABjwvpmhZB4jY-fYtbKFRMrNRMygQPY85KLRB4jleDw5cQMgsdFl8ERSBRqIMRmMJhSplcqopavw6pwHUwmD8wLxEQA+RqLOPkBMrkpaZRgAC0AC8AIKHgBaqi0dVRtvI47hDQAZM-kZVej8BF1EQikS9X3WTZoAAZV+R8Zl6CBUGPag-yRb02E-ShvwCFlQU0fBdH0Lt-GIStoC3dMrHyTxM1PXYwAQPMA0zKcBDzFsqF4OIliYJU7RgH4eEgf1CxAR00z1TxKFkYBKAAc4AY-iJVoG49xoEzAZM16aBY3jRMYHIyjqP9cJLWtOMYFY+0wAdNNMhEPtxGoGlTxAAgggs8gx1naolDUNcNwWbiEic8zfgUGoBC8pENAhRYkBYNoWzuckmFaCj3AQEoACYADZb3KCACTmJp8Di1zuP+CkQJC-hekifVAjcPx2PxA5TwOXphTqhrTwfAAGBoAGpoFkQkCuaVoShK8N2j-aADgGA5oEAzoqUQ1h+l4UB8jCXLxvQWYfMWfAxgClyKWUXozsO5zfgubbVBZMEmjZTdNJXC7AvIdDMOgbDOT8fDoGoIjExIsjkqomiq3o-hGNyZjWKNaAHVQfh3GkGBgHwuI7UINxUkwViqFkYohXAFZendVwUcIcBagAFVE1y6cJwt1UwFsQnQVI4g07ctOgUGEH0hGkZRyArN7MQB2gGkACFhY8McCGp3hGfIYKlHcyGwvXeYFkVtBlfp6BeqRPXafp5DUOgABSaA0t-JEuugAB+aa5s4A4AA0Dk+-Atx3NpTYNwnelJYU916LAAEYzjS0EtBnawYE11Rb2kAgShKMgQC+BoEW14a-cTWUxi+ZQutUe3i+zyhlEjiuXaz0vy6N6aAE03arr47tZQl8AwyKvo5XDU3ZiQrDjJAbTWyxBdb7HFIU3jWHyRW+Q4-7oHiD31niJBajGeebHw6TZPiB0QCYHJBcR5GPEgMncI9SmwgsJybXhFXmfsTB72IVwucfoXJM-N-pTn-p2fA3ZrISwkGAscL9UBvzjJOCqagNaoIrnnPahFnr6VfpGZBIcwDpxKDfFGud877RwTzFcZCPBQVXg+A4QIiEkLaugC4tQwiDW8jrKhLQ2hcNEpXOhkgLb8B-IeSO803zsMrgAcg9vI-KVCno0O7vdYavtcFCPJDbO2k0HYyIjG4BRrd5HOyFrfSQyhdHQEPNAOu0BODsI0T3XoGomC1EOECB6vdWQD2+rhX6M8AZpiBoKcggVwCCwiBKWI-EkjEHIOkC46NLCmXnrjf0RZgiikDJEYMkpQj8UEsUB+kDoBOCATAEBiNWBpBQtBXIB84xEFtChKJLFmZRIsjEgMcSimSDFqIfsEgaT0jJG5NW041Ba2wUVKQDJ5AeVmeoTB0BlBQj6MtBh4wmFAluk0RZr0XIzNChs7Z1JfgOSOuBfxhVch3GgrBCkTwfbQGipgMavxmgUi6oIP5AAefyl1yDiK6IC1ARskQvMoCo-apI5C9AILcAIJRTm-CguMcSJRUCcJbnC2Y3dHoLCAUsskH1AlD0qamYAK9sRWF4jkSoKEwDrzGrUIIG8cjZwzA0AMpF+QVX0q2FYOSKXEGPLEoMIYKmGCqRTeW9g3DCmgJ-QU38Ea3GjLJTp4q5JIpgtzHctTdJ6lbChUyaMFxsDZevfG2J0jaogLqkZNlJa6KOEgSZcgxwqvQMKc5M5OC8FIhZdA8y+EWruHYpEJQvK8WTreFsFoHxnVRFSI1g1VrcO9SUANwoHkxtcmGyQ9Vs6SCTEiK52ay6qAhWhAe+ABF4pYsI+C9jI51GGssVYQFti7FKJmLYPxJCdOgAAEiwIWgIoI+K2h3q5USPRyAwFyJSag2bMxDUWIslYawkSTICKidAbxgBtu4V9dYpEK2kTyMWxZvKKR2JtmWu9VaIAfPJcoA9aTFxHL7p9IJlSQL5AdNwFI+RoVnzltIZovAvnSFYliC+6o1Q5F2LaQ07bLUFPcKxew-A3jWpwbfEyiTkipGdQGeAVEUAYHJp6dUqqAjqqdXql1FoJUQHA5B7cqAT5Mcpm08A4l2NM2EpvaAnwD7fzlFwPjqRtwAFu4ZLA49fHVYBhPywQUg-wBZ1SlmzGeyg9ZZBRnyFE6TRBL62ibDg9mjmSgIMKSGAVlHklpAgQq6pz0YBHA05JwZrEGxGYDLx8SUAmBpKM0xdA7ZUDxEBhmV48HIbF2PJYd1MCwl63E-G2dwa1AXFE1aSgJXVAXH0wQucC4ly8HQUoXhTRW3lfEr0Sg7NUolHYRQljgaT21HWptPrQQdq7WjfgPyxlg0UmYR87RBXKCsIzv11rqiS0IbzUgUN4bwywsoKx3Nol839bcfgLRI02i1exAirbxkYU7bO60dcjsXaztse22Q3r7GOIrgoY7Q3sXmHxFI4tYJ-q1moNN-aT3jYvd+60EFs7G3-ekZ94Hwpvu7Zbk4oHrH62XYCVQ0Eu74e4OMiS5t1D-aLZEP3dkOFKloggEymAcZyOC14xB5T0GT6H2hzETp8NDW2ng+MXg3LVQSvHRAeDvK3gmktPh0x8QCblN054Wd7H0A0eoA6bTPGlNQcEzJbXeDEEEMM45ksWYczmf+pZ+lNn4h2ei45uMzn4iuajLKmInmEhJJSD5k1vMgua+bEGMLnhGycaiw52L+ZHMJaSyl8JaWNf03iMkfg+8QC5bGflsTlBTAgQ8JQAAMrUSgRwcSLnvf67HARg01f90g+ri5jsriRDWewzXpybYWCc3YVWKRo4gIwnxxbZu2nm0iBnTQvmxSea5OxiU+a6RKE8bK9BcpTeGvu1Y4+a1ZuWbj0SgH9pPsXKfyk0Js1rZKAegbB7L+yBTktm7Gcntn+hB1viH+tYLsO3vgvdreF+BIgEA9pTjQjgl+sNPOpQDDj-i-ouv-n0IAX1ouBcG4BwlbkgrMI2rAWov7NTkgQ9LTuSrOlSszpyGzhzmRu4CZNQLzvxgLjJELigSLq2PDJ8NQLwFwViBzChOJJ4AAAdSAS5WBS4y4YaN5pZKpq6YDZ5MzypGBbBQDjyUC3xVzUBdJEzKGDIhjCTu6q5ubxIaGKrMa650z66cZG6upWByTsH87m6+bOA1LQCR455q6x4p4J6FBJ5xap4wyJYdjULETSZR6bzED54ZiF5dg9ijK2Q4IramAAAiLQk8cYrYNeGwp4LEH6vebQxWqy9QC+lCI+a+IB6A9+k+0+zCj6tRmGGwAI+2kgEacyGyEUiwc+EAC+rsHy+Bz+G2WCbR2IfQqKEA6KVyXqPqyy42bgswFO2iMAiOmY06taF+kxAI9a9a6gexEAtc6gdcqgoImY3cCOSIWxWAOxZIygxxpxhxTx6YUxBx5xlx36VOtodB+AsxqwvqjI0ysoXi8IWC0acU3eqI5kPwJQDxcg-ipKIGCqWwLu1mVg7uKwnunGJhxSVu7mkopkiQVGPmgsdGyAaA6A1hT88smuEmRMYYrMMeueaolh7KnhNhIm3W2IrkuIdumoDuZmFmVmbuog9mMWTmUxvuHJHmfEweZJ6QIyZ6pRCJ9Mbe0pHMXejWFI-e8KVRCytRoi9+VyMscG6pwc6ImI2IAp+IxKxyrR1u789+p0Z0oi1+M2vygBrAKsQxS+UUMUOBeQ6+P2m8rQoiMI++eU2CjyIZg2QaFR-AFIoiH+Ryw0ra6BK2vphsmBvQgB5eleBRdeDelavABaLeZWvJHMu0hiCZMBsZI+zpyCaZFIPpKsbiyBqBcOhUzZlArArZeZBZvA2RSAuRnSxZRRrAJRFZrGkOpOCwpKcZTYPwn4TA-AhwdGtQ7sLcmuLReQMJF8G5Bwss1iO5-UkZni3ic0QIPae6Tyh565hwfgfZVQc0-U6Bo8liVyYCfWr5t4V55ZzRzigYSC-ZHiXiQFt5axdORc3ufJ35VIv54ByCAFkFM+IFKF4FgFM+VKbIiyesVJGAFIGwawlJDG+wBwyMKQTAQIwghFFFUEAQQJSxQ0iyJAtQ5gqAtwFIDF1J+ZbwhwwwxgAAcsYH4MYGiCBHRTgHxRgAJeWRxWYBYLcBcI7mxbUa4NoeKibIgIxaqZuaeCBCBKeMmEcDJXJTSQZVpezisGpWZoSEAA
 */
class Playfair {
  private keyword: string;
  private matrix: string[][];

  /**
   * Inicia a classe
   * @param keyword Chave de cifragem do algoritimo
   */
  constructor(keyword: string) {
    if (!this.isKeyValid(keyword)) {
      throw new Error("Ops, keyword must have 5 unique letters");
    }

    this.keyword = keyword.toUpperCase();
    this.matrix = this.getMatrix();
  }

  /**
   * Verifica se a chave de cifragem é válida, ou seja, se é composta por 5 caracteres alfabéticos.
   * @param keyword Chave de cifragem a ser checada
   * @returns Retorna `true` caso a chave seja válida e `false` em caso contrário
   */
  private isKeyValid = (keyword: string): boolean => {
    return (/[a-zA-Z]/).test(keyword) && keyword.length === 5 && new Set(keyword).size === keyword.length;
  };

  /**
   * Cria e retorna um `Array` de `string` contendo todas as letras do alfabeto com exceção da letra `K`. 
   * @returns `Array` de caracteres do alfabeto
   */
  private getAlphabet = (): string[] => {
    let alphabet: string[] = [];

    for (const x of Array(26).keys()) {
      const letter = String.fromCharCode("A".charCodeAt(0) + x);

      if (letter !== "K" && !this.keyword.includes(letter)) {
        alphabet = [...alphabet, letter];
      }
    }

    return alphabet;
  };

  /**
   * Cria e retorna um `Array` de `string` contendo os bigramas criados a partir do texto claro.
   * @param plainText Texto a ser convertido
   * @returns Array de bigramas
   */
  private getBigram = (plainText: string): string[] => {
    plainText += plainText.length % 2 === 0 ? "" : "X";

    return (plainText.match(/.{1,2}/g) as string[]).map((value) => {
      return value[0] === value[1] ? value[0] + "Y" : value;
    });
  };

  /**
   * Reverte a referencia de Y para letras duplicadas e o X no final para criação do bloco de bigramas.
   * @param deciphered Texto a ser estripado
   * @returns Array estripado
   */
  private strip = (deciphered: string[]): string[] => {
    return deciphered.map((bigram) => {
      return bigram.split("").map((char, index) => {
        if (index === bigram.length -1 && char === 'X') {
          return;
        }

        return index % 2 !== 0 && char === 'Y' ? bigram[index - 1] : char;
      }).join("")
    });
  }

  /**
   * Cria e retorna a tabela de cifragem do algoritmo, criado a partir da chave de cifragem e do alfabeto.
   * @returns Array bidimensional representando a tabela de cifragem
   */
  private getMatrix = (): string[][] => {
    const matrix: string[][] = [this.keyword.split("")];
    const alphabet: string[] = this.getAlphabet();
    const size = 5;

    for (let i = 0; i < alphabet.length; i += size) {
      matrix.push(alphabet.slice(i, i + size));
    }

    return matrix;
  };

  /**
   * Recupera as coordenadas (linha e coluna) de uma string dentro da matriz de cifragem.
   * @param search Texto a ser buscado dentro da matriz
   * @returns Array contendo as coordenadas do termo buscado
   */
  private indexOfMatrix = (search: string): number[] => {
    const index = ([] as string[]).concat(...this.matrix).indexOf(search);
    const numColumns = this.matrix[0].length;

    if (index === -1)
      throw new Error(`Element ${search} does not exists on the matrix`);

    const row = Math.trunc(index / numColumns);
    const col = index % numColumns;

    return [row, col];
  };

  /**
   * Substitui o bigrama informado pelo seu correspondente cifrado segundo as regras do algoritimo de Playfair
   * @param search Termo de busca da substituição
   * @param replace Texto com o qual será substituído o termo de busca
   * @param decipher Caso seja `true` executa o processo reverso (decifragem) do algoritimo
   * @returns O texto cifrado em caso de sucesso, caso contrário retorna uma string vazia
   */
  private replace = (search: string[], replace: string[], decipher: boolean): string => {
    if (replace.every((char) => search.includes(char))) {
      let res: string = "";

      replace.map((char) => {
        const indexOf: number = search.indexOf(char);
        
        if (decipher) {
          res += indexOf > 0 ? search[indexOf - 1] : search.slice(-1);
        } else {
          res += indexOf < search.length - 1 ? search[indexOf + 1] : search[0];
        }
      });

      return res;
    }

    return "";
  };

  /**
   * Usa as regras de substituição para elementos da mesma linha ou da mesma coluna para cifrar o texto.
   * @param search Termo de busca da substituição
   * @param decipher Caso seja `true` executa o processo reverso (decifragem) do algoritimo
   * @returns O texto cifrado em caso de sucesso, caso contrário retorna o texto original
   */
  private replaceInSameLineOrColumn = (search: string, decipher: boolean = false): string => {
    const arr: string[] = search.split("");
    let res: string = "";

    for (const index of Array(5).keys()) {
      const row: string[] = this.matrix[index];
      const col: string[] = this.matrix.map((row) => row[index]);

      if ((res = this.replace(row, arr, decipher)).length) {
        return res;
      } else if ((res = this.replace(col, arr, decipher)).length) {
        return res;
      }
    }

    return search;
  };

  /**
   * Usa as regras de substituição para elementos que não pertencem à mesma linha ou coluna para cifrar o texto.
   * Essa regra vale tanto para cifragem como para decifragem.
   * @param search Termo de busca da substituição
   * @returns O texto cifrado em caso de sucesso, caso contrário retorna o texto original
   */
  private replaceInDifferentLineAndColumn = (search: string): string => {
    const arr: string[] = search.split("");
    const corners: number[][] = [];
    let res: string = "";

    arr.map((char) => corners.push(this.indexOfMatrix(char)));

    res += `${this.matrix[corners[0][0]][corners[1][1]]}`;
    res += `${this.matrix[corners[1][0]][corners[0][1]]}`;

    return res;
  };

  showMatrix = (): void => {
    console.table(this.matrix);
  }

  /**
   * Executa o processo de cifragem e decifragem do algoritimo de Playfair.
   * @param text Texto a ser cifrado ou decifrado
   * @param revert Caso seja `true` executa o processo reverso (decifragem) do algoritimo
   */
  run = (text: string, revert: boolean = false): string => {
    const bigram: string[] = this.getBigram(text.toUpperCase());
    const ciphered: string[] = [...bigram];
    let replacedText: string = "";

    for (const index of bigram.keys()) {
      const search: string = bigram[index];

      if ((replacedText = this.replaceInSameLineOrColumn(search, revert)) !== search) {
        ciphered[index] = replacedText;
      } else {
        ciphered[index] = this.replaceInDifferentLineAndColumn(search);
      }
    }

    console.log("Plain: " + text);
    console.log("Bigram: " + bigram.join(" "))
    console.log("Ciphered: " + (revert ? this.strip(ciphered).join("") : ciphered.join("")));

    return revert ? this.strip(ciphered).join("") : ciphered.join("");
  };
}

const playfair = new Playfair("grito");
playfair.showMatrix();

playfair.run("MARIANA");
playfair.run("FEITFVCV", true);
